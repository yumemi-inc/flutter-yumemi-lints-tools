// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'lint_rule.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;
/// @nodoc
mixin _$LintRule {

 Rule get rule;
/// Create a copy of LintRule
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$LintRuleCopyWith<LintRule> get copyWith => _$LintRuleCopyWithImpl<LintRule>(this as LintRule, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is LintRule&&(identical(other.rule, rule) || other.rule == rule));
}


@override
int get hashCode => Object.hash(runtimeType,rule);

@override
String toString() {
  return 'LintRule(rule: $rule)';
}


}

/// @nodoc
abstract mixin class $LintRuleCopyWith<$Res>  {
  factory $LintRuleCopyWith(LintRule value, $Res Function(LintRule) _then) = _$LintRuleCopyWithImpl;
@useResult
$Res call({
 Rule rule
});


$RuleCopyWith<$Res> get rule;

}
/// @nodoc
class _$LintRuleCopyWithImpl<$Res>
    implements $LintRuleCopyWith<$Res> {
  _$LintRuleCopyWithImpl(this._self, this._then);

  final LintRule _self;
  final $Res Function(LintRule) _then;

/// Create a copy of LintRule
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? rule = null,}) {
  return _then(_self.copyWith(
rule: null == rule ? _self.rule : rule // ignore: cast_nullable_to_non_nullable
as Rule,
  ));
}
/// Create a copy of LintRule
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RuleCopyWith<$Res> get rule {
  
  return $RuleCopyWith<$Res>(_self.rule, (value) {
    return _then(_self.copyWith(rule: value));
  });
}
}


/// @nodoc


class DartLintRule implements LintRule {
  const DartLintRule(this.rule);
  

@override final  Rule rule;

/// Create a copy of LintRule
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DartLintRuleCopyWith<DartLintRule> get copyWith => _$DartLintRuleCopyWithImpl<DartLintRule>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DartLintRule&&(identical(other.rule, rule) || other.rule == rule));
}


@override
int get hashCode => Object.hash(runtimeType,rule);

@override
String toString() {
  return 'LintRule.dart(rule: $rule)';
}


}

/// @nodoc
abstract mixin class $DartLintRuleCopyWith<$Res> implements $LintRuleCopyWith<$Res> {
  factory $DartLintRuleCopyWith(DartLintRule value, $Res Function(DartLintRule) _then) = _$DartLintRuleCopyWithImpl;
@override @useResult
$Res call({
 Rule rule
});


@override $RuleCopyWith<$Res> get rule;

}
/// @nodoc
class _$DartLintRuleCopyWithImpl<$Res>
    implements $DartLintRuleCopyWith<$Res> {
  _$DartLintRuleCopyWithImpl(this._self, this._then);

  final DartLintRule _self;
  final $Res Function(DartLintRule) _then;

/// Create a copy of LintRule
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? rule = null,}) {
  return _then(DartLintRule(
null == rule ? _self.rule : rule // ignore: cast_nullable_to_non_nullable
as Rule,
  ));
}

/// Create a copy of LintRule
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RuleCopyWith<$Res> get rule {
  
  return $RuleCopyWith<$Res>(_self.rule, (value) {
    return _then(_self.copyWith(rule: value));
  });
}
}

/// @nodoc


class FlutterLintRule implements LintRule {
  const FlutterLintRule(this.rule);
  

@override final  Rule rule;

/// Create a copy of LintRule
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$FlutterLintRuleCopyWith<FlutterLintRule> get copyWith => _$FlutterLintRuleCopyWithImpl<FlutterLintRule>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is FlutterLintRule&&(identical(other.rule, rule) || other.rule == rule));
}


@override
int get hashCode => Object.hash(runtimeType,rule);

@override
String toString() {
  return 'LintRule.flutter(rule: $rule)';
}


}

/// @nodoc
abstract mixin class $FlutterLintRuleCopyWith<$Res> implements $LintRuleCopyWith<$Res> {
  factory $FlutterLintRuleCopyWith(FlutterLintRule value, $Res Function(FlutterLintRule) _then) = _$FlutterLintRuleCopyWithImpl;
@override @useResult
$Res call({
 Rule rule
});


@override $RuleCopyWith<$Res> get rule;

}
/// @nodoc
class _$FlutterLintRuleCopyWithImpl<$Res>
    implements $FlutterLintRuleCopyWith<$Res> {
  _$FlutterLintRuleCopyWithImpl(this._self, this._then);

  final FlutterLintRule _self;
  final $Res Function(FlutterLintRule) _then;

/// Create a copy of LintRule
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? rule = null,}) {
  return _then(FlutterLintRule(
null == rule ? _self.rule : rule // ignore: cast_nullable_to_non_nullable
as Rule,
  ));
}

/// Create a copy of LintRule
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RuleCopyWith<$Res> get rule {
  
  return $RuleCopyWith<$Res>(_self.rule, (value) {
    return _then(_self.copyWith(rule: value));
  });
}
}


/// @nodoc
mixin _$Rule {

 String get name; String get description; List<String> get categories; RuleState get state;@JsonKey(name: 'incompatible') List<String> get incompatibles; List<RuleSet> get sets; FixStatus get fixStatus; String get details;@JsonKey(name: 'sinceDartSdk') Since get since;
/// Create a copy of Rule
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$RuleCopyWith<Rule> get copyWith => _$RuleCopyWithImpl<Rule>(this as Rule, _$identity);

  /// Serializes this Rule to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is Rule&&(identical(other.name, name) || other.name == name)&&(identical(other.description, description) || other.description == description)&&const DeepCollectionEquality().equals(other.categories, categories)&&(identical(other.state, state) || other.state == state)&&const DeepCollectionEquality().equals(other.incompatibles, incompatibles)&&const DeepCollectionEquality().equals(other.sets, sets)&&(identical(other.fixStatus, fixStatus) || other.fixStatus == fixStatus)&&(identical(other.details, details) || other.details == details)&&(identical(other.since, since) || other.since == since));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,name,description,const DeepCollectionEquality().hash(categories),state,const DeepCollectionEquality().hash(incompatibles),const DeepCollectionEquality().hash(sets),fixStatus,details,since);

@override
String toString() {
  return 'Rule(name: $name, description: $description, categories: $categories, state: $state, incompatibles: $incompatibles, sets: $sets, fixStatus: $fixStatus, details: $details, since: $since)';
}


}

/// @nodoc
abstract mixin class $RuleCopyWith<$Res>  {
  factory $RuleCopyWith(Rule value, $Res Function(Rule) _then) = _$RuleCopyWithImpl;
@useResult
$Res call({
 String name, String description, List<String> categories, RuleState state,@JsonKey(name: 'incompatible') List<String> incompatibles, List<RuleSet> sets, FixStatus fixStatus, String details,@JsonKey(name: 'sinceDartSdk') Since since
});


$SinceCopyWith<$Res> get since;

}
/// @nodoc
class _$RuleCopyWithImpl<$Res>
    implements $RuleCopyWith<$Res> {
  _$RuleCopyWithImpl(this._self, this._then);

  final Rule _self;
  final $Res Function(Rule) _then;

/// Create a copy of Rule
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? name = null,Object? description = null,Object? categories = null,Object? state = null,Object? incompatibles = null,Object? sets = null,Object? fixStatus = null,Object? details = null,Object? since = null,}) {
  return _then(_self.copyWith(
name: null == name ? _self.name : name // ignore: cast_nullable_to_non_nullable
as String,description: null == description ? _self.description : description // ignore: cast_nullable_to_non_nullable
as String,categories: null == categories ? _self.categories : categories // ignore: cast_nullable_to_non_nullable
as List<String>,state: null == state ? _self.state : state // ignore: cast_nullable_to_non_nullable
as RuleState,incompatibles: null == incompatibles ? _self.incompatibles : incompatibles // ignore: cast_nullable_to_non_nullable
as List<String>,sets: null == sets ? _self.sets : sets // ignore: cast_nullable_to_non_nullable
as List<RuleSet>,fixStatus: null == fixStatus ? _self.fixStatus : fixStatus // ignore: cast_nullable_to_non_nullable
as FixStatus,details: null == details ? _self.details : details // ignore: cast_nullable_to_non_nullable
as String,since: null == since ? _self.since : since // ignore: cast_nullable_to_non_nullable
as Since,
  ));
}
/// Create a copy of Rule
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$SinceCopyWith<$Res> get since {
  
  return $SinceCopyWith<$Res>(_self.since, (value) {
    return _then(_self.copyWith(since: value));
  });
}
}


/// @nodoc
@JsonSerializable()

class _Rule extends Rule {
  const _Rule({required this.name, required this.description, required final  List<String> categories, required this.state, @JsonKey(name: 'incompatible') required final  List<String> incompatibles, required final  List<RuleSet> sets, required this.fixStatus, required this.details, @JsonKey(name: 'sinceDartSdk') required this.since}): _categories = categories,_incompatibles = incompatibles,_sets = sets,super._();
  factory _Rule.fromJson(Map<String, dynamic> json) => _$RuleFromJson(json);

@override final  String name;
@override final  String description;
 final  List<String> _categories;
@override List<String> get categories {
  if (_categories is EqualUnmodifiableListView) return _categories;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_categories);
}

@override final  RuleState state;
 final  List<String> _incompatibles;
@override@JsonKey(name: 'incompatible') List<String> get incompatibles {
  if (_incompatibles is EqualUnmodifiableListView) return _incompatibles;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_incompatibles);
}

 final  List<RuleSet> _sets;
@override List<RuleSet> get sets {
  if (_sets is EqualUnmodifiableListView) return _sets;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_sets);
}

@override final  FixStatus fixStatus;
@override final  String details;
@override@JsonKey(name: 'sinceDartSdk') final  Since since;

/// Create a copy of Rule
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$RuleCopyWith<_Rule> get copyWith => __$RuleCopyWithImpl<_Rule>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$RuleToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _Rule&&(identical(other.name, name) || other.name == name)&&(identical(other.description, description) || other.description == description)&&const DeepCollectionEquality().equals(other._categories, _categories)&&(identical(other.state, state) || other.state == state)&&const DeepCollectionEquality().equals(other._incompatibles, _incompatibles)&&const DeepCollectionEquality().equals(other._sets, _sets)&&(identical(other.fixStatus, fixStatus) || other.fixStatus == fixStatus)&&(identical(other.details, details) || other.details == details)&&(identical(other.since, since) || other.since == since));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,name,description,const DeepCollectionEquality().hash(_categories),state,const DeepCollectionEquality().hash(_incompatibles),const DeepCollectionEquality().hash(_sets),fixStatus,details,since);

@override
String toString() {
  return 'Rule(name: $name, description: $description, categories: $categories, state: $state, incompatibles: $incompatibles, sets: $sets, fixStatus: $fixStatus, details: $details, since: $since)';
}


}

/// @nodoc
abstract mixin class _$RuleCopyWith<$Res> implements $RuleCopyWith<$Res> {
  factory _$RuleCopyWith(_Rule value, $Res Function(_Rule) _then) = __$RuleCopyWithImpl;
@override @useResult
$Res call({
 String name, String description, List<String> categories, RuleState state,@JsonKey(name: 'incompatible') List<String> incompatibles, List<RuleSet> sets, FixStatus fixStatus, String details,@JsonKey(name: 'sinceDartSdk') Since since
});


@override $SinceCopyWith<$Res> get since;

}
/// @nodoc
class __$RuleCopyWithImpl<$Res>
    implements _$RuleCopyWith<$Res> {
  __$RuleCopyWithImpl(this._self, this._then);

  final _Rule _self;
  final $Res Function(_Rule) _then;

/// Create a copy of Rule
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? name = null,Object? description = null,Object? categories = null,Object? state = null,Object? incompatibles = null,Object? sets = null,Object? fixStatus = null,Object? details = null,Object? since = null,}) {
  return _then(_Rule(
name: null == name ? _self.name : name // ignore: cast_nullable_to_non_nullable
as String,description: null == description ? _self.description : description // ignore: cast_nullable_to_non_nullable
as String,categories: null == categories ? _self._categories : categories // ignore: cast_nullable_to_non_nullable
as List<String>,state: null == state ? _self.state : state // ignore: cast_nullable_to_non_nullable
as RuleState,incompatibles: null == incompatibles ? _self._incompatibles : incompatibles // ignore: cast_nullable_to_non_nullable
as List<String>,sets: null == sets ? _self._sets : sets // ignore: cast_nullable_to_non_nullable
as List<RuleSet>,fixStatus: null == fixStatus ? _self.fixStatus : fixStatus // ignore: cast_nullable_to_non_nullable
as FixStatus,details: null == details ? _self.details : details // ignore: cast_nullable_to_non_nullable
as String,since: null == since ? _self.since : since // ignore: cast_nullable_to_non_nullable
as Since,
  ));
}

/// Create a copy of Rule
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$SinceCopyWith<$Res> get since {
  
  return $SinceCopyWith<$Res>(_self.since, (value) {
    return _then(_self.copyWith(since: value));
  });
}
}

/// @nodoc
mixin _$Since {





@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is Since);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'Since()';
}


}

/// @nodoc
class $SinceCopyWith<$Res>  {
$SinceCopyWith(Since _, $Res Function(Since) __);
}


/// @nodoc


class SinceDartSdk extends Since {
  const SinceDartSdk(this.version): super._();
  

 final  Version version;

/// Create a copy of Since
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$SinceDartSdkCopyWith<SinceDartSdk> get copyWith => _$SinceDartSdkCopyWithImpl<SinceDartSdk>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is SinceDartSdk&&(identical(other.version, version) || other.version == version));
}


@override
int get hashCode => Object.hash(runtimeType,version);

@override
String toString() {
  return 'Since.dartSdk(version: $version)';
}


}

/// @nodoc
abstract mixin class $SinceDartSdkCopyWith<$Res> implements $SinceCopyWith<$Res> {
  factory $SinceDartSdkCopyWith(SinceDartSdk value, $Res Function(SinceDartSdk) _then) = _$SinceDartSdkCopyWithImpl;
@useResult
$Res call({
 Version version
});




}
/// @nodoc
class _$SinceDartSdkCopyWithImpl<$Res>
    implements $SinceDartSdkCopyWith<$Res> {
  _$SinceDartSdkCopyWithImpl(this._self, this._then);

  final SinceDartSdk _self;
  final $Res Function(SinceDartSdk) _then;

/// Create a copy of Since
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? version = null,}) {
  return _then(SinceDartSdk(
null == version ? _self.version : version // ignore: cast_nullable_to_non_nullable
as Version,
  ));
}


}

/// @nodoc


class SinceUnreleased extends Since {
  const SinceUnreleased(): super._();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is SinceUnreleased);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'Since.unreleased()';
}


}




// dart format on
