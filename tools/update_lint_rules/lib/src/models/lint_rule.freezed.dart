// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'lint_rule.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;
/// @nodoc
mixin _$LintRule {

 Rule get rule;
/// Create a copy of LintRule
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$LintRuleCopyWith<LintRule> get copyWith => _$LintRuleCopyWithImpl<LintRule>(this as LintRule, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is LintRule&&(identical(other.rule, rule) || other.rule == rule));
}


@override
int get hashCode => Object.hash(runtimeType,rule);

@override
String toString() {
  return 'LintRule(rule: $rule)';
}


}

/// @nodoc
abstract mixin class $LintRuleCopyWith<$Res>  {
  factory $LintRuleCopyWith(LintRule value, $Res Function(LintRule) _then) = _$LintRuleCopyWithImpl;
@useResult
$Res call({
 Rule rule
});


$RuleCopyWith<$Res> get rule;

}
/// @nodoc
class _$LintRuleCopyWithImpl<$Res>
    implements $LintRuleCopyWith<$Res> {
  _$LintRuleCopyWithImpl(this._self, this._then);

  final LintRule _self;
  final $Res Function(LintRule) _then;

/// Create a copy of LintRule
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? rule = null,}) {
  return _then(_self.copyWith(
rule: null == rule ? _self.rule : rule // ignore: cast_nullable_to_non_nullable
as Rule,
  ));
}
/// Create a copy of LintRule
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RuleCopyWith<$Res> get rule {
  
  return $RuleCopyWith<$Res>(_self.rule, (value) {
    return _then(_self.copyWith(rule: value));
  });
}
}


/// @nodoc


class DartLintRule implements LintRule {
  const DartLintRule(this.rule);
  

@override final  Rule rule;

/// Create a copy of LintRule
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DartLintRuleCopyWith<DartLintRule> get copyWith => _$DartLintRuleCopyWithImpl<DartLintRule>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DartLintRule&&(identical(other.rule, rule) || other.rule == rule));
}


@override
int get hashCode => Object.hash(runtimeType,rule);

@override
String toString() {
  return 'LintRule.dart(rule: $rule)';
}


}

/// @nodoc
abstract mixin class $DartLintRuleCopyWith<$Res> implements $LintRuleCopyWith<$Res> {
  factory $DartLintRuleCopyWith(DartLintRule value, $Res Function(DartLintRule) _then) = _$DartLintRuleCopyWithImpl;
@override @useResult
$Res call({
 Rule rule
});


@override $RuleCopyWith<$Res> get rule;

}
/// @nodoc
class _$DartLintRuleCopyWithImpl<$Res>
    implements $DartLintRuleCopyWith<$Res> {
  _$DartLintRuleCopyWithImpl(this._self, this._then);

  final DartLintRule _self;
  final $Res Function(DartLintRule) _then;

/// Create a copy of LintRule
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? rule = null,}) {
  return _then(DartLintRule(
null == rule ? _self.rule : rule // ignore: cast_nullable_to_non_nullable
as Rule,
  ));
}

/// Create a copy of LintRule
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RuleCopyWith<$Res> get rule {
  
  return $RuleCopyWith<$Res>(_self.rule, (value) {
    return _then(_self.copyWith(rule: value));
  });
}
}

/// @nodoc


class FlutterLintRule implements LintRule {
  const FlutterLintRule(this.rule);
  

@override final  Rule rule;

/// Create a copy of LintRule
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$FlutterLintRuleCopyWith<FlutterLintRule> get copyWith => _$FlutterLintRuleCopyWithImpl<FlutterLintRule>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is FlutterLintRule&&(identical(other.rule, rule) || other.rule == rule));
}


@override
int get hashCode => Object.hash(runtimeType,rule);

@override
String toString() {
  return 'LintRule.flutter(rule: $rule)';
}


}

/// @nodoc
abstract mixin class $FlutterLintRuleCopyWith<$Res> implements $LintRuleCopyWith<$Res> {
  factory $FlutterLintRuleCopyWith(FlutterLintRule value, $Res Function(FlutterLintRule) _then) = _$FlutterLintRuleCopyWithImpl;
@override @useResult
$Res call({
 Rule rule
});


@override $RuleCopyWith<$Res> get rule;

}
/// @nodoc
class _$FlutterLintRuleCopyWithImpl<$Res>
    implements $FlutterLintRuleCopyWith<$Res> {
  _$FlutterLintRuleCopyWithImpl(this._self, this._then);

  final FlutterLintRule _self;
  final $Res Function(FlutterLintRule) _then;

/// Create a copy of LintRule
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? rule = null,}) {
  return _then(FlutterLintRule(
null == rule ? _self.rule : rule // ignore: cast_nullable_to_non_nullable
as Rule,
  ));
}

/// Create a copy of LintRule
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RuleCopyWith<$Res> get rule {
  
  return $RuleCopyWith<$Res>(_self.rule, (value) {
    return _then(_self.copyWith(rule: value));
  });
}
}


/// @nodoc
mixin _$Rule {

 String get name; List<String> get categories;@JsonKey(name: 'deprecatedDetails') String get details;@_StateJsonConverter() Map<RuleState, Since> get state;
/// Create a copy of Rule
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$RuleCopyWith<Rule> get copyWith => _$RuleCopyWithImpl<Rule>(this as Rule, _$identity);

  /// Serializes this Rule to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is Rule&&(identical(other.name, name) || other.name == name)&&const DeepCollectionEquality().equals(other.categories, categories)&&(identical(other.details, details) || other.details == details)&&const DeepCollectionEquality().equals(other.state, state));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,name,const DeepCollectionEquality().hash(categories),details,const DeepCollectionEquality().hash(state));

@override
String toString() {
  return 'Rule(name: $name, categories: $categories, details: $details, state: $state)';
}


}

/// @nodoc
abstract mixin class $RuleCopyWith<$Res>  {
  factory $RuleCopyWith(Rule value, $Res Function(Rule) _then) = _$RuleCopyWithImpl;
@useResult
$Res call({
 String name, List<String> categories,@JsonKey(name: 'deprecatedDetails') String details,@_StateJsonConverter() Map<RuleState, Since> state
});




}
/// @nodoc
class _$RuleCopyWithImpl<$Res>
    implements $RuleCopyWith<$Res> {
  _$RuleCopyWithImpl(this._self, this._then);

  final Rule _self;
  final $Res Function(Rule) _then;

/// Create a copy of Rule
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? name = null,Object? categories = null,Object? details = null,Object? state = null,}) {
  return _then(_self.copyWith(
name: null == name ? _self.name : name // ignore: cast_nullable_to_non_nullable
as String,categories: null == categories ? _self.categories : categories // ignore: cast_nullable_to_non_nullable
as List<String>,details: null == details ? _self.details : details // ignore: cast_nullable_to_non_nullable
as String,state: null == state ? _self.state : state // ignore: cast_nullable_to_non_nullable
as Map<RuleState, Since>,
  ));
}

}


/// @nodoc
@JsonSerializable()

class _Rule extends Rule {
  const _Rule({required this.name, required final  List<String> categories, @JsonKey(name: 'deprecatedDetails') required this.details, @_StateJsonConverter() required final  Map<RuleState, Since> state}): _categories = categories,_state = state,super._();
  factory _Rule.fromJson(Map<String, dynamic> json) => _$RuleFromJson(json);

@override final  String name;
 final  List<String> _categories;
@override List<String> get categories {
  if (_categories is EqualUnmodifiableListView) return _categories;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_categories);
}

@override@JsonKey(name: 'deprecatedDetails') final  String details;
 final  Map<RuleState, Since> _state;
@override@_StateJsonConverter() Map<RuleState, Since> get state {
  if (_state is EqualUnmodifiableMapView) return _state;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableMapView(_state);
}


/// Create a copy of Rule
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$RuleCopyWith<_Rule> get copyWith => __$RuleCopyWithImpl<_Rule>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$RuleToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _Rule&&(identical(other.name, name) || other.name == name)&&const DeepCollectionEquality().equals(other._categories, _categories)&&(identical(other.details, details) || other.details == details)&&const DeepCollectionEquality().equals(other._state, _state));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,name,const DeepCollectionEquality().hash(_categories),details,const DeepCollectionEquality().hash(_state));

@override
String toString() {
  return 'Rule(name: $name, categories: $categories, details: $details, state: $state)';
}


}

/// @nodoc
abstract mixin class _$RuleCopyWith<$Res> implements $RuleCopyWith<$Res> {
  factory _$RuleCopyWith(_Rule value, $Res Function(_Rule) _then) = __$RuleCopyWithImpl;
@override @useResult
$Res call({
 String name, List<String> categories,@JsonKey(name: 'deprecatedDetails') String details,@_StateJsonConverter() Map<RuleState, Since> state
});




}
/// @nodoc
class __$RuleCopyWithImpl<$Res>
    implements _$RuleCopyWith<$Res> {
  __$RuleCopyWithImpl(this._self, this._then);

  final _Rule _self;
  final $Res Function(_Rule) _then;

/// Create a copy of Rule
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? name = null,Object? categories = null,Object? details = null,Object? state = null,}) {
  return _then(_Rule(
name: null == name ? _self.name : name // ignore: cast_nullable_to_non_nullable
as String,categories: null == categories ? _self._categories : categories // ignore: cast_nullable_to_non_nullable
as List<String>,details: null == details ? _self.details : details // ignore: cast_nullable_to_non_nullable
as String,state: null == state ? _self._state : state // ignore: cast_nullable_to_non_nullable
as Map<RuleState, Since>,
  ));
}


}

/// @nodoc
mixin _$Since {





@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is Since);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'Since()';
}


}

/// @nodoc
class $SinceCopyWith<$Res>  {
$SinceCopyWith(Since _, $Res Function(Since) __);
}


/// @nodoc


class SinceDartSdk extends Since {
  const SinceDartSdk(this.version): super._();
  

 final  Version version;

/// Create a copy of Since
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$SinceDartSdkCopyWith<SinceDartSdk> get copyWith => _$SinceDartSdkCopyWithImpl<SinceDartSdk>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is SinceDartSdk&&(identical(other.version, version) || other.version == version));
}


@override
int get hashCode => Object.hash(runtimeType,version);

@override
String toString() {
  return 'Since.dartSdk(version: $version)';
}


}

/// @nodoc
abstract mixin class $SinceDartSdkCopyWith<$Res> implements $SinceCopyWith<$Res> {
  factory $SinceDartSdkCopyWith(SinceDartSdk value, $Res Function(SinceDartSdk) _then) = _$SinceDartSdkCopyWithImpl;
@useResult
$Res call({
 Version version
});




}
/// @nodoc
class _$SinceDartSdkCopyWithImpl<$Res>
    implements $SinceDartSdkCopyWith<$Res> {
  _$SinceDartSdkCopyWithImpl(this._self, this._then);

  final SinceDartSdk _self;
  final $Res Function(SinceDartSdk) _then;

/// Create a copy of Since
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? version = null,}) {
  return _then(SinceDartSdk(
null == version ? _self.version : version // ignore: cast_nullable_to_non_nullable
as Version,
  ));
}


}

/// @nodoc


class SinceUnreleased extends Since {
  const SinceUnreleased(): super._();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is SinceUnreleased);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'Since.unreleased()';
}


}




// dart format on
